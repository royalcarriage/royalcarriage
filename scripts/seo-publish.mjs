#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DRAFTS_DIR = path.join(__dirname, '../packages/content/seo-bot/drafts');
const PUBLISHED_DIR = path.join(__dirname, '../packages/content/seo-bot/published');
const MANIFESTS_DIR = path.join(__dirname, '../packages/content/seo-bot/manifests');
const TOPICS_FILE = path.join(__dirname, '../packages/content/seo-bot/queue/topics.json');

// Helper function to count words accurately
function countWords(text) {
  return text.split(/\s+/).filter(word => word.length > 0).length;
}

async function loadDraft(filename) {
  const filepath = path.join(DRAFTS_DIR, filename);
  const data = await fs.readFile(filepath, 'utf-8');
  return { data: JSON.parse(data), filepath, filename };
}

async function loadTopics() {
  const data = await fs.readFile(TOPICS_FILE, 'utf-8');
  return JSON.parse(data);
}

async function saveTopics(data) {
  await fs.writeFile(TOPICS_FILE, JSON.stringify(data, null, 2), 'utf-8');
}

function execCommand(command, options = {}) {
  try {
    return execSync(command, {
      encoding: 'utf-8',
      stdio: options.silent ? 'pipe' : 'inherit',
      ...options
    });
  } catch (error) {
    throw new Error(`Command failed: ${command}\n${error.message}`);
  }
}

function getCurrentBranch() {
  return execCommand('git rev-parse --abbrev-ref HEAD', { silent: true }).trim();
}

function hasUncommittedChanges() {
  const status = execCommand('git status --porcelain', { silent: true }).trim();
  return status.length > 0;
}

async function createBranch(branchName) {
  console.log(`üåø Creating branch: ${branchName}`);
  
  const currentBranch = getCurrentBranch();
  
  if (hasUncommittedChanges()) {
    console.error('‚ùå Working directory has uncommitted changes. Please commit or stash them first.');
    process.exit(1);
  }
  
  // Ensure we're up to date
  console.log('   Fetching latest changes...');
  execCommand('git fetch origin', { silent: true });
  
  // Create and checkout new branch
  execCommand(`git checkout -b ${branchName}`);
  
  return currentBranch;
}

async function moveDraftToPublished(draft) {
  const publishedPath = path.join(PUBLISHED_DIR, draft.filename);
  
  // Move file
  await fs.rename(draft.filepath, publishedPath);
  
  console.log(`üì¶ Moved draft to published: ${draft.filename}`);
  return publishedPath;
}

async function createManifest(draft, publishedPath) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const manifestFilename = `manifest-${draft.data.topicId}-${timestamp}.json`;
  const manifestPath = path.join(MANIFESTS_DIR, manifestFilename);
  
  const manifest = {
    topicId: draft.data.topicId,
    keyword: draft.data.keyword,
    title: draft.data.content.title,
    slug: draft.data.content.slug,
    targetSite: draft.data.targetSite,
    publishedFile: draft.filename,
    publishedAt: new Date().toISOString(),
    wordCount: draft.data.content.sections.reduce((sum, s) => {
      return sum + countWords(s.content);
    }, 0),
    metadata: {
      title: draft.data.content.title,
      metaDescription: draft.data.content.metaDescription,
      sections: draft.data.content.sections.length,
      images: draft.data.content.images?.length || 0,
      internalLinks: draft.data.content.internalLinks?.length || 0
    }
  };
  
  await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2), 'utf-8');
  
  console.log(`üìã Created manifest: ${manifestFilename}`);
  return { manifestPath, manifestFilename, manifest };
}

async function updateTopicStatus(topicId, status) {
  const data = await loadTopics();
  const topic = data.topics.find(t => t.id === topicId);
  
  if (topic) {
    topic.status = status;
    topic.publishedAt = new Date().toISOString();
    await saveTopics(data);
  }
}

async function commitChanges(draft, manifest) {
  console.log('üìù Committing changes...');
  
  // Stage files
  execCommand('git add packages/content/seo-bot/published/', { silent: true });
  execCommand('git add packages/content/seo-bot/manifests/', { silent: true });
  execCommand('git add packages/content/seo-bot/drafts/', { silent: true });
  execCommand('git add packages/content/seo-bot/queue/topics.json', { silent: true });
  
  // Commit - write message to temp file to avoid shell injection
  const commitMessage = `feat(seo): publish "${draft.data.content.title}"

Topic: ${draft.data.topicId}
Keyword: ${draft.data.keyword}
Word count: ${manifest.manifest.wordCount}
Target site: ${draft.data.targetSite}

Generated by seo-publish automation`;
  
  const tmpFile = path.join(os.tmpdir(), `commit-msg-${Date.now()}.txt`);
  await fs.writeFile(tmpFile, commitMessage, 'utf-8');
  
  try {
    execCommand(`git commit -F "${tmpFile}"`, { silent: true });
    console.log('‚úÖ Changes committed');
  } finally {
    await fs.unlink(tmpFile).catch(() => {});
  }
}

async function pushBranch(branchName) {
  console.log('‚¨ÜÔ∏è  Pushing branch to remote...');
  
  try {
    execCommand(`git push -u origin ${branchName}`, { silent: true });
    console.log('‚úÖ Branch pushed successfully');
    return true;
  } catch (error) {
    console.error('‚ö†Ô∏è  Failed to push branch:', error.message);
    console.log('   You may need to push manually or check your git credentials');
    return false;
  }
}

async function createPullRequest(branchName, draft, manifest) {
  console.log('\nüì¨ Creating Pull Request...');
  
  const prTitle = `SEO Content: ${draft.data.content.title}`;
  const prBody = `## SEO Content Publication

**Topic ID:** ${draft.data.topicId}
**Keyword:** ${draft.data.keyword}
**Target Site:** ${draft.data.targetSite}

### Content Details
- **Title:** ${draft.data.content.title}
- **Slug:** ${draft.data.content.slug}
- **Word Count:** ${manifest.manifest.wordCount}
- **Sections:** ${manifest.manifest.metadata.sections}
- **Images:** ${manifest.manifest.metadata.images}
- **Internal Links:** ${manifest.manifest.metadata.internalLinks}

### Meta Description
${draft.data.content.metaDescription}

### Published Files
- \`${manifest.manifest.publishedFile}\`
- \`${manifest.manifestFilename}\`

---
*Generated by SEO automation pipeline*`;

  // Try to create PR using GitHub CLI with file-based approach to avoid injection
  try {
    execCommand(`gh --version`, { silent: true });
    
    const tmpTitle = path.join(os.tmpdir(), `pr-title-${Date.now()}.txt`);
    const tmpBody = path.join(os.tmpdir(), `pr-body-${Date.now()}.txt`);
    
    await fs.writeFile(tmpTitle, prTitle, 'utf-8');
    await fs.writeFile(tmpBody, prBody, 'utf-8');
    
    try {
      const prUrl = execCommand(
        `gh pr create --title-file "${tmpTitle}" --body-file "${tmpBody}" --base main`,
        { silent: true }
      ).trim();
      
      console.log('‚úÖ Pull Request created successfully!');
      console.log(`   ${prUrl}`);
      return prUrl;
    } finally {
      await fs.unlink(tmpTitle).catch(() => {});
      await fs.unlink(tmpBody).catch(() => {});
    }
  } catch (error) {
    console.log('‚ö†Ô∏è  GitHub CLI not available or failed');
    console.log('\nüìã Manual PR Creation Instructions:');
    console.log('‚îÄ'.repeat(60));
    console.log(`1. Go to your repository on GitHub`);
    console.log(`2. Click "Pull Requests" ‚Üí "New Pull Request"`);
    console.log(`3. Select base: main, compare: ${branchName}`);
    console.log(`4. Use this title:`);
    console.log(`   ${prTitle}`);
    console.log(`5. Use this description:`);
    console.log('‚îÄ'.repeat(60));
    console.log(prBody);
    console.log('‚îÄ'.repeat(60));
    return null;
  }
}

async function publish(draftFilename, options = {}) {
  console.log(`\nüöÄ Starting publication process for: ${draftFilename}\n`);
  
  // Load draft
  const draft = await loadDraft(draftFilename);
  
  // Create branch
  const branchName = `seo/${draft.data.topicId}-${draft.data.content.slug}`;
  const originalBranch = await createBranch(branchName);
  
  try {
    // Move draft to published
    const publishedPath = await moveDraftToPublished(draft);
    
    // Create manifest
    const { manifestPath, manifestFilename, manifest } = await createManifest(draft, publishedPath);
    
    // Update topic status
    await updateTopicStatus(draft.data.topicId, 'published');
    
    // Commit changes
    await commitChanges(draft, { manifestFilename, manifest });
    
    // Push branch
    const pushed = await pushBranch(branchName);
    
    // Create PR
    if (pushed && !options.noPr) {
      await createPullRequest(branchName, draft, { manifestFilename, manifest });
    } else if (!pushed) {
      console.log('\nüìã To push manually and create PR:');
      console.log(`   git push -u origin ${branchName}`);
      console.log(`   gh pr create --base main --head ${branchName}`);
    }
    
    console.log('\n‚úÖ Publication process complete!');
    console.log(`   Branch: ${branchName}`);
    console.log(`   Next: Review and merge the PR to publish`);
    
  } catch (error) {
    console.error('\n‚ùå Publication failed:', error.message);
    console.log(`\nüîÑ Attempting to restore original branch: ${originalBranch}`);
    try {
      execCommand(`git checkout ${originalBranch}`, { silent: true });
      execCommand(`git branch -D ${branchName}`, { silent: true });
      console.log('‚úÖ Cleaned up failed publication attempt');
    } catch (cleanupError) {
      console.error('‚ö†Ô∏è  Manual cleanup may be required');
    }
    process.exit(1);
  }
}

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
    console.log(`
Usage: node seo-publish.mjs [options]

Options:
  --draft <filename>   Publish specific draft file
  --no-pr              Skip automatic PR creation
  --help, -h           Show this help message

Publication Process:
  1. Creates a new git branch (seo/<topic-id>-<slug>)
  2. Moves draft from drafts/ to published/
  3. Creates manifest entry in manifests/
  4. Updates topic status in queue
  5. Commits all changes
  6. Pushes branch to remote
  7. Creates Pull Request (if GitHub CLI available)

Prerequisites:
  - Clean working directory (no uncommitted changes)
  - GitHub CLI installed (optional, for automatic PR creation)
  - Git credentials configured for push access

Example:
  node seo-publish.mjs --draft topic-001-chicago-airport-limo.json
    `);
    return;
  }
  
  const options = {
    noPr: args.includes('--no-pr')
  };
  
  if (args[0] === '--draft' && args[1]) {
    await publish(args[1], options);
  } else {
    console.error('‚ùå Invalid arguments. Use --help for usage information.');
    process.exit(1);
  }
}

main().catch(error => {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
});
